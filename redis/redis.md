# Redis



1.   Redis为什么快

>   1.   Redis是纯内存操作，C语言编写
>   2.   Redis是单线程操作
>   3.   数据简单，数据操作也相对简单
>   4.   Redis采用epoll作为I/O多路复用技术的实现



2.   RDB

>   什么是RDB？
>
>   *   RDB全称Redis Database Backup file，是Redis数据备份文件，也被称为Redis数据快照，用于将当前内存中的数据记录到磁盘中，记录的是二进制数据并进行压缩
>
>   什么时候会执行RDB？
>
>   1.   手动执行
>        *   save：会阻塞主进程
>        *   bgsave：后台执行
>   2.   Redis停机时执行
>   3.   触发设定的RDB条件
>        *   save 300 10：表示300秒内如果有10个key被修改就执行
>
>   RDB写时复制？
>
>   *   后台执行RDB时会通过Linux的fork函数复制主进程的信息得到子进程，它会有与主进程相同的指针指向内存中的数据页，子进程就通过指针读取内存数据写入RDB文件
>   *   由于主进程和子进程都可以获取这份数据，也就是说这份数据是共享的
>   *   当主进程执行读操作时，直接访问共享内存
>   *   当主进程执行写操作时，就会拷贝一份对应的数据执行写操作，完成写操作后数据页指向旧数据的指针就会指向新的数据
>   *   当RDB执行完后，操作系统就会回收那些没有被引用的数据



3.   AOF

>   什么是AOF？
>
>   *   AOF全称Append Only File，是追加文件。Redis处理的每一个写命令都会记录在AOF文件，记录的是命令。
>
>   AOF的同步频率？
>
>   *   Always：同步刷盘，可靠性高，几乎不丢失数据，但是性能消耗大
>   *   everysec：每秒刷盘，性能适中，最多会丢失一秒的数据
>   *   no：操作系统控制刷盘，性能最好，但是可靠性差，可能会丢失大量数据
>
>   AOF的文件重写：
>
>   *   因为一个key可能会产生多次的写操作，但只有最后一次的写操作才有意义，因此AOF文件重写能够读取内存然后对每个key生成一条写操作记录到AOF文件中
>   *   可以通过bgrewriteaof命令开启AOF文件重写，Redis也会在触发我们设定的重写条件时进行重写，例如增长超过多少百分比、文件体积到达多大



4.   RDB与AOF对比

>   RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用
>
>   |                | RDB                                  | AOF                                                        |
>   | -------------- | ------------------------------------ | ---------------------------------------------------------- |
>   | 持久化方式     | 定时对整个内存做快照                 | 记录每一次执行的命令                                       |
>   | 数据完整性     | 不完整，两次备份之间数据会丢失       | 相对完整，取决于同步频率                                   |
>   | 文件大小       | 相对较小，记录二进制文件并压缩       | 相对较大，记录的是每条数据的命令                           |
>   | 宕机恢复速度   | 很快                                 | 慢                                                         |
>   | 数据恢复优先级 | 数据完整性不如AOF，优先级低          | 数据完整性较好，优先级高                                   |
>   | 系统资源占用   | 消耗大量CPU和内存，资源占用高        | 主要是磁盘IO，消耗低，但AOF文件重写依旧会占用大量CPU和内存 |
>   | 使用场景       | 可用容忍部分数据丢失，追求执行速度快 | 对数据安全性要求较高                                       |



5.   Redis的全量复制

>   ![image-20231030224458856](img/image-20231030224458856.png)
>
>   我们可以在某个节点中执行`slaveof 主IP 主port`来使当前节点作为目标节点的slave节点，主从在第一次建立连接时会进行全量复制。
>
>   1.   slave向master发起数据同步请求，如果有replid和offset的话也会发送给master
>        *   Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集，每一个master 都有唯一的replid，slave会继承master节点的replid
>        *   offset：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大
>   2.   master判断replid是否与自己的一致或偏移量是否被覆盖，如果不一致或偏移量被覆盖则执行全量复制，否则会执行增量复制
>   3.   如果执行增量复制，则返回replid和offset给slave，slave接收到后保存版本信息
>   4.   master执行`bgsave`，生成RDB文件并发送给slave，slave接收到后会清空本地数据并加载RDB文件
>   5.   master在记录RDB文件的期间可能会继续产生写操作，这时会使用repl_baklog文件来记录这些写操作命令并持续发送给slave
>        *   repl_baklog：记录Redis处理过的命令日志及offset，包括master当前的offset和slave依旧拷贝到的offset，是一个固定大小的环形数组。
>   6.   slave执行接收到的命令，并会一直保持与master之间的同步
>   7.   至此全量同步完成



6.   Redis的增量复制

>   ![image-20231030224517442](img/image-20231030224517442.png)
>
>   1.   slave向master发起数据同步请求，并将自己的replid和offset发送给master
>   2.   master判断replid是否和自己的相同，并判断offset是否未被覆盖，如果都是则进行增量同步并回复continue，否则进行全量同步
>   3.   master从repl_baklog中获取offset后的数据并发送给slave
>   4.   slave执行接收到的命令
>   5.   至此增量同步完成



7.   Redis是单线程的吗？为什么？

>   Redis是单线程的吗？
>
>   *   Redis4.0以前是完全单线程的
>
>   *   从Redis4.0开始支持后台线程工作，即执行IO和读写数据使用单线程，执行数据持久化等操作使用多线程
>   *   Redis6.0引入多线程IO，但只是用于处理网络数据的读写和协议的解析，而执行命令依旧是单线程
>
>   为什么是单线程？
>
>   1.   单线程模式方便开发调试
>   2.   Redis内部使用了基于epoll的多路复用
>   3.   Redis主要的性能瓶颈是内存和网络带宽



8.   Redis事务

>   Redis的事务的本质是一组命令的批处理，不具备像DBMS一样的ACID特性。这组命令在执行过程中会被顺序地一次性执行完毕，只要没有出现语法错误，这组命令在执行期间是不会被中断的。
>
>   *   这组命令中的某些命令的执行失败不会影响到其它命令的执行，不会引发回滚
>   *   这组命令仅通过乐观锁实现简单的隔离性，没有复杂的隔离级别
>   *   这组命令的执行结果是被写入内存的，是否持久化取决于Redis的持久化策略，与事务无关