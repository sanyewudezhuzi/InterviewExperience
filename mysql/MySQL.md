# MySQL相关面试题



# 5. 分库分表

1.   为什么要分库分表

>   使用单数据库存在一些性能瓶颈：
>
>   *   IO问题：请求数据太多产生大量的磁盘IO，导致效率降低
>   *   CPU问题：请求数据太多，进行分组、排序、多表查询等操作都会耗费大量的CPU资源进行计算
>
>   通过分库分表就可以解决以上问题，它的思想就是将数据分散存储，使得单一数据库、表的数据量变小来缓解单一数据库的性能问题。



2.   分库分表的拆分策略

>   *   垂直拆分
>       *   垂直分库：以表为依据，根据业务不同拆分到不同库中
>           *   每个库的表都不相同
>           *   每个库的数据都不相同
>           *   所有库加起来才是全量数据
>       *   垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中
>           *   每表的结构都不相同
>           *   每表的数据都不相同
>           *   所有表加起来是全量数据
>   *   水平拆分
>       *   水平分库：以字段为依据，将一个库的数据拆分到多个库中
>           *   每个库的表是相同的
>           *   每个库的数据都不相同
>           *   所有库加起来才是全量数据
>       *   水平分表：以字段为依据，将一个表的数据拆分到多个表
>           *   每个表的结构是相同的
>           *   每个表的数据都不相同
>           *   所有表加起来是全量数据



3.   分库分表的实现技术

>   *   shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，然后解析、改写和做路由处理。需要自行编码实现，只支持java语言，性能较高。
>   *   MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。



# 6. 锁

1.   按锁的粒度划分，MySQL中有哪几种锁？

>   *   全局锁：每次操作锁定数据库中的所有表
>
>   除全局锁外，主要有三种：
>
>   *   表级锁：MyISAM引擎和InnoDB引擎支持，每次操作锁定操作的表，锁定粒度较大，开销最小，但并发度较低
>   *   页级锁：BDB引擎支持，锁定粒度介于行级锁和表级锁中间
>   *   行级锁：InnoDB引擎支持，每次操作锁定操作的行，锁定粒度最小，并发性能最好，但开销较大



2.   介绍一下共享锁和排他锁

>   *   共享锁（Shared Lock，S锁）：有时称为读锁，针对同一份数据，多个事务的读操作可以同时进行而不会相互影响
>   *   排他锁（Exclusive Lock，X锁）：有时称为写锁，当前的写操作没有完成前，它会阻断其它的共享锁和排他锁，即只能有一个事务执行写操作，并防止其它事务读取正在写入的资源
>       *   这里的写操作主要是指删和改，插入新增操作一般是不加排他锁的，只通过一种称为隐式锁的结构来保护新增的数据在事务提交前不被其它事务访问
>
>   什么时候加锁呢？
>
>   *   正常的select语句是不会加任何锁的
>   *   执行写入操作会加排他锁
>   *   `SELECT ... LOCK IN SHARE MODE;`语句会加共享锁，目的是阻塞写操作
>   *   `SELECT ... FOR UPDATE;`语句会加排他锁，目的是阻塞其它事务获取共享锁或排他锁



3.   介绍一下意向锁

>   意向锁的作用：
>
>   1.   意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁共存。
>   2.   意向锁是一种不与行级锁冲突表级锁，这一点非常重要。
>   3.   表明“某个事务正在某些行持有了锁或该事务准备去持有锁”，以此减少数据库对表锁的检测
>
>   意向锁是由存储引擎自己维护的，用户无法手动操作意向锁，当我们为数据行加共享或排他锁之前，InnoDB会先获取该数据行所在数据表的对应意向锁。
>
>   在数据表场景中，例如现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排他锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；但是如果有意向锁，那么T2就只需检查意向锁，不需要再检查各个页或行锁。



4.   redo log和undo log

>   我们都知道事务的四大特性ACID，它的隔离性是由锁机制和MVCC来实现的，而原子性、一致性、持久性是通过redo和undo日志来实现的。
>
>   *   redo log称为重做日志，提供再写入的操作，用来保证事务的持久性。它是InnoDB生成的日志，记录的是物理日志，例如哪个页多少偏移量操作了什么数据。
>
>       *   解析
>
>           redo log由redo log buffer和redo log file组成，缓冲池存在于内存中，redo log file存在于磁盘中。我们在访问数据页之前，需要把在磁盘上的数据页缓存到缓冲池中才可以访问，所有的修改操作都必须先更新缓冲池中的数据，然后缓冲池中的脏页会根据checkPoint机制以一定的频率被写入redo log file，最终再同步到数据库中。InnoDB引擎的事务采用了WAL技术（Write-Ahead Logging），这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功。而缓冲池的作用就是来优化CPU和磁盘之间的鸿沟，这样能保证整体的性能不会下降太快。
>
>       *   优点
>
>           *   因为它只记录操作，占用的空间小，降低了刷盘频率
>           *   redo日志是顺序写入的，顺序IO比随机IO会快很多，在事务的执行过程中，redo log会不断地进行记录
>
>   *   undo log称为回滚日志，用于回滚行记录到某个特定版本，保证事务的原子性和一致性。它记录的是每个修改操作的逆操作，是逻辑日志，例如你执行了insert操作它就会记录一条delete操作，执行了delete操作它就会记录一条insert操作，执行了update操作它就会记录一条update操作将其更改为更改前的数据。
>
>       *   解析
>
>           当我们的事务执行到一半时出现了一些错误，或者说整个服务器产生错误，又或者直接断电了，这时候为了保证事务的原子性就需要使用undo日志执行回滚操作。
>
>       *   优点
>
>           *   提供回滚和MVCC
>
>   注：这里所说的修改操作指的是增删改操作



5.   redo log和bin log的区别

>   redo log是存储引擎层产生的，而bin log是数据库层产生的。假设一个事务对表做了10w行的记录插入，在这个过程中一直不断地往redo log顺序记录，而bin log不会记录，直到这个事务提交后才会一次写入到bin log文件中。而且bin log是不一定会写入成功的，而redo log是一定要写入成功事务才能提交的，bin log如果没有成功，就可以通过redo log来重新写入，保证事务的持久性。



6.   MVCC

>   MVCC全称Multi-Version Concurrency Control，即多版本并发控制，用于维护一个数据的多个版本，使得读写操作没有冲突。MVCC的实现依赖于数据库记录中的隐藏字段、undo log、readView。
>
>   *   隐藏字段：在一个数据表中除了我们自己设置的字段外，还有三个隐藏字段分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID
>
>       *   DB_TRX_ID：最近修改事务的ID，记录插入这条记录或最后一次修改该记录的事务ID，默认为1，每次修改后进行自增
>       *   DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本，用于配合undo log一起使用
>       *   DB_ROW_ID：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段
>
>       因此每次修改一个字段，至少会修改一次事务ID和回滚指针。
>
>   *   undo log：在执行增删改操作时候产生的便于数据回滚的数据。当insert时，产生的undo日志在事务提交后就会被删除，而update和delete操作产生的undo日志不仅在回滚时需要，MVCC版本访问也需要，不会被立即删除。它里面其实是以一个版本链的方式进行存储。
>
>   *   readView：即读视图，是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（即未提交的事务）id。
>
>       *   当前读：读取的是记录的最新版本且需要保证其它并发事务不能修改当前记录，会对读取的记录进行加锁。其它事务进行读取时，即使遇到阻塞也要拿到最新的数据。
>       *   快照读：普通的不加锁select就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。
>           *   Read Committed：每次select都生成一个快照读
>           *   Repeatable Read：开启事务后第一次执行select语句才生成快照读
>       *   Read View包含了四个核心字段：
>           *   m_ids：当前活跃的事务ID集合
>           *   min\_trx\_id：最小活跃事务ID
>           *   max\_trx\_id：预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）
>           *   creator\_trx\_id：ReadView创建者的事务ID

