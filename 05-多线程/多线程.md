# 多线程面试题



# 一、线程

## 1. Java中创建线程的方式

>   Java创建线程一共有四种方式。
>
>   第一种是创建一个类继承Thread，然后重写Thread的run方法，优点是实现起来非常简单，缺点就是限制了类的拓展性，因为Java中的类只能实现单继承。
>
>   第二种是创建一个类实现Runnable接口，重写run方法，优点是程序的拓展性好，缺点就是没有返回值。
>
>   第三种是创建一个类实现Callable接口，重写call方法，优点是可以获取线程运行的返回值，缺点是编程比较复杂。
>
>   第四种是使用线程池创建，可以使用`Executors.newFixedThreadPool()`创建，也可以使用`ThreadPoolExecutor()`来自定义连接池。



## 2. Runnable和Callable的区别

>   Runnable接口的run方法没有返回值，不能手动抛出异常
>
>   Callable接口的run方法有返回值且支持泛型，允许抛出异常



## 3. 线程中start和run方法

>   开启一个线程只需要调用start方法，此时会创建一个线程进入就绪态，jvm就会自动调用run方法在开启的线程中执行。
>
>   线程对象直接调用run方法并没有开启新的线程，此时这个run方法就相当于一个普通的方法在当前线程中执行。



## 4. Java中线程的状态

>   *   new：新建状态，创建线程对象时候的状态
>   *   runnable：可运行状态，调用start()方法
>   *   blocked：阻塞状态，没有获得锁对象。获得锁对象后会再进入到runnable状态
>   *   wait：等待状态，线程调用了wait()方法后就会进入wait状态。被其它线程唤醒后如果获得了锁对象就会进入runnable状态，否则进入阻塞状态
>   *   timed-waiting：计时等待状态，当线程调用sleep()或者wait()后就会进入计时等待状态，需要注意的是sleep()不会释放锁，也就是等待给定时间或者被其它线程唤醒后就会再次进入runnable状态，而wait()会释放锁，在等待时间结束或者被其它线程唤醒后需要再次获得锁才能进入runnable状态，否则就会进入阻塞状态。
>   *   terminated：线程结束状态，即线程被终止了。



## 5. 线程相关的基本方法

>   *   wait线程等待：调用该方法后，线程从runnable状态进入等待状态并会释放锁，直到被其它线程唤醒后才会结束状态
>   *   sleep线程睡眠：调用该方法后，线程从runnable状态进入计时等待状态，他不会释放锁，在等待时间结束后会重新进入runnable状态
>   *   join等待其它线程终止：当调用join方法时，当前线程就会进入阻塞状态，等待另一个线程运行结束后，当前线程才会再次进入runnable状态
>   *   notify线程唤醒：唤醒在某个使用wait进入等待或计时等待的单个线程。还有一个notifyall方法是唤醒所有使用wait进入等待或计时等待的线程。
>   *   yield线程让步：使当前线程让出CPU，与其它线程一起重新竞争
>   *   interrupt线程中断：中断一个线程，通过给这个线程一个通知信号影响这个线程内部，但不会因此改变线程的状态



## 6. wait()和sleep()

>   wait()来自Object类，使用后如果传入参数就会进入计时等待状态，如果没有传入参数就会进入等待状态，在等待的过程中会释放锁，直到被其它线程唤醒或者等待时间结束后会根据是否再次获取到锁进入runnable状态或者阻塞状态
>
>   sleep()来自Thread类，使用时需要捕获异常，可以在任意位置使用然后进入计时等待状态，此时不会释放锁，在等待时间结束后会重新进入runnable状态。







# 二、线程池

## 1. 常用线程池

>   newCachedThreadPool：创建一个可进行缓存重复利用的线程池
>
>   newFixedThreadPool：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，线程池中的线程处于一定的量，可以很好的控制线程的并发量
>
>   newSingleThreadExecutor：创建一个使用单个worker线程的Executor，以无界队列方式来运行该线程。线程中最多执行一个线程，之后提交的线程将会排在队列中依次执行
>
>   newSingleThreadScheduledExecutor：创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期执行
>
>   newScheduledThreadPool：创建一个线程池，它可以安排在给定延迟后运行命令或者定期执行
>
>   newWorkStealingPool：创建一个带并行级别的线程池，并行级别决定了同一时刻最多有多少个线程在执行，默认为cpu处理器数



## 2. 自定义线程池参数

```java
public ThreadPoolExecutor(
	int corePoolSize, // 核心线程数
    int maximumPoolSize, // 最大线程数
    long keepAliveTime, // 临时线程存活时间
    TimeUnit unit, // 临时线程存活时间单位
    BlockingQueue<Runnable> workQueue, // 阻塞等待队列
    ThreadFactory threadFactory, // 创建线程的工厂
    RejectedExecutionHandler handler // 拒绝策略
)
```



## 3. 拒绝策略

>   1.   `ThreadPoolExecutor.AbortPolicy`：丢弃任务并抛出异常，这是默认的拒绝策略
>   2.   `ThreadPoolExecutor.DiscardPolicy`：丢弃任务，但是不抛出异常
>   3.   `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新提交被拒绝的任务
>   4.   `ThreadPoolExecutor.CallerRunsPolicy`：由调用线程（提交任务的线程）处理该任务



## 4. 线程池执行流程

>   1.   提交任务后，从线程池中取出核心线程执行任务
>   2.   如果任务数超过核心线程数，则会尝试将任务放入阻塞队列中
>   3.   如果阻塞队列也放满了，则会启用临时线程来执行接下来的任务
>   4.   如果临时线程也启用完了，即线程数已达最大线程数，则会执行拒绝策略



## 5. 线程池的关闭

>   关闭线程池，可以通过shutdown和shutdownNow两个方法，它的原理是遍历线程池中的所有线程，然后依次中断。
>
>   1.   shutdownNow首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行和未执行任务的线程，并返回等待任务的列表
>   2.   shutdown只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行任务的线程



## 6. 线程池是如何实现复用的

>   线程池底层其实是采用生产者、消费者的模式来实现复用的。这个生产者消费者模型，其实就是通过一个中间容器来解耦任务处理的过程，生产者不断的生产任务保存到容器里面，消费者不断的去容器里面消费任务。
>
>   在线程池里面，因为需要保证工作线程的重复使用，并且这些线程需要保证有任务的时候工作，没有任务的时候等待并且释放CPU的资源，所以它使用了阻塞队列来实现这样的一个需求，提交任务到线程池里的线程称为生产者线程，它不断地往线程池中添加任务，这些任务会保存到阻塞队列里面，然后线程池中的工作线程会不断地从阻塞队列中获取任务去执行，基于阻塞队列这样一个特性，如果阻塞队列里面没有任务，那么这些工作线程就会阻塞等待，直到又有新的任务进来的时候，这些工作线程又会被唤醒进而执行任务。







# 三、锁

## 1. synchronized和Lock的区别

>   1.   synchronized是Java的关键词，而Lock是由JUC(`java.util.concurrent`)包提供的一个接口类
>   2.   synchronized使用后会自动解锁，而Lock需要手动在finally代码块中解锁
>   3.   synchronized无法判断是否已经获取到锁，而Lock通过`tryLock()`方法可以判断是否已经获取到锁
>   4.   两者的底层实现不同，synchronized是同步阻塞，采用的是悲观并发策略；Lock是同步非阻塞，采用的是乐观并发策略，底层基于volatile关键字和CAS算法实现
>   5.   Lock提供了更多的实现方法，而且可响应中断、可定时，而synchronized关键字不能响应中断
>   6.   synchronized关键字是非公平锁，即不能保证等待锁的那些线程的获取顺序，而Lock的子类ReentrantLock默认是非公平锁，但也可以通过一个布尔参数的构造实例化出一个公平锁，公平锁就是先等待的线程会先获得锁。公平锁因为需要维护一个等待锁资源的队列，所以性能不如非公平锁
>   7.   在资源竞争不激烈的情况下，synchronized性能优于Lock，而资源竞争激烈的情况下，Lock性能更优

