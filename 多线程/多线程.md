# 多线程面试题



1.   Java中创建线程的方式

>   Java创建线程一共有四种方式。
>
>   第一种是创建一个类继承Thread，然后重写Thread的run方法，优点是实现起来非常简单，缺点就是限制了类的拓展性，因为Java中的类只能实现单继承。
>
>   第二种是创建一个类实现Runnable接口，重写run方法，优点是程序的拓展性好，缺点就是没有返回值。
>
>   第三种是创建一个类实现Callable接口，重写call方法，优点是可以获取线程运行的返回值，缺点是编程比较复杂。
>
>   第四种是使用线程池创建，可以使用`Executors.newFixedThreadPool()`创建，也可以使用`ThreadPoolExecutor()`来自定义连接池。



2.   Runnable和Callable的区别

>   Runnable接口的run方法没有返回值，不能手动抛出异常
>
>   Callable接口的run方法有返回值且支持泛型，允许抛出异常



3.   线程中start和run方法

>   开启一个线程只需要调用start方法，此时会创建一个线程进入就绪态，jvm就会自动调用run方法在开启的线程中执行。
>
>   线程对象直接调用run方法并没有开启新的线程，此时这个run方法就相当于一个普通的方法在当前线程中执行。



4.   Java中线程的状态

>   *   new：新建状态，创建线程对象时候的状态
>   *   runnable：可运行状态，调用start()方法
>   *   blocked：阻塞状态，没有获得锁对象。获得锁对象后会再进入到runnable状态
>   *   wait：等待状态，线程调用了wait()方法后就会进入wait状态。被其它线程唤醒后如果获得了锁对象就会进入runnable状态，否则进入阻塞状态
>   *   timed-waiting：计时等待状态，当线程调用sleep()或者wait()后就会进入计时等待状态，需要注意的是sleep()不会释放锁，也就是等待给定时间或者被其它线程唤醒后就会再次进入runnable状态，而wait()会释放锁，在等待时间结束或者被其它线程唤醒后需要再次获得锁才能进入runnable状态，否则就会进入阻塞状态。
>   *   terminated：线程结束状态，即线程被终止了。



5.   线程相关的基本方法

>   *   wait线程等待：调用该方法后，线程从runnable状态进入等待状态并会释放锁，直到被其它线程唤醒后才会结束状态
>   *   sleep线程睡眠：调用该方法后，线程从runnable状态进入计时等待状态，他不会释放锁，在等待时间结束后会重新进入runnable状态
>   *   join等待其它线程终止：当调用join方法时，当前线程就会进入阻塞状态，等待另一个线程运行结束后，当前线程才会再次进入runnable状态
>   *   notify线程唤醒：唤醒在某个使用wait进入等待或计时等待的单个线程。还有一个notifyall方法是唤醒所有使用wait进入等待或计时等待的线程。
>   *   yield线程让步：使当前线程让出CPU，与其它线程一起重新竞争
>   *   interrupt线程中断：中断一个线程，通过给这个线程一个通知信号影响这个线程内部，但不会因此改变线程的状态



6.   wait()和sleep()

>   wait()来自Object类，使用后如果传入参数就会进入计时等待状态，如果没有传入参数就会进入等待状态，在等待的过程中会释放锁，直到被其它线程唤醒或者等待时间结束后会根据是否再次获取到锁进入runnable状态或者阻塞状态
>
>   sleep()来自Thread类，使用时需要捕获异常，可以在任意位置使用然后进入计时等待状态，此时不会释放锁，在等待时间结束后会重新进入runnable状态。



7.   常用线程池

>   newCachedThreadPool：创建一个可进行缓存重复利用的线程池
>
>   newFixedThreadPool：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，线程池中的线程处于一定的量，可以很好的控制线程的并发量
>
>   newSingleThreadExecutor：创建一个使用单个worker线程的Executor，以无界队列方式来运行该线程。线程中最多执行一个线程，之后提交的线程将会排在队列中依次执行
>
>   newSingleThreadScheduledExecutor：创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期执行
>
>   newScheduledThreadPool：创建一个线程池，它可以安排在给定延迟后运行命令或者定期执行
>
>   newWorkStealingPool：创建一个带并行级别的线程池，并行级别决定了同一时刻最多有多少个线程在执行，默认为cpu处理器数



8.   自定义线程参数

```java
public ThreadPoolExecutor(
	int corePoolSize, // 核心线程数
    int maximumPoolSize, // 最大线程数
    long keepAliveTime, // 临时线程存活时间
    TimeUnit unit, // 临时线程存活时间单位
    BlockingQueue<Runnable> workQueue, // 阻塞等待队列
    ThreadFactory threadFactory, // 创建线程的工厂
    RejectedExecutionHandler handler // 拒绝策略
)
```



9.   多线程的情况下使用map集合如何保证线程安全（ConcurrentHashMap）

>   其实要使map能够并发安全的执行，我们目前学到的方法有同步代码块、同步方法、上Lock锁，但执行的效率不高，因为在同一时刻只能有一个线程操作map。
>
>   然后我们的这种思想其实Java已经帮我们实现了，Java有个类叫HashTable，他几乎在所有的方法上都加上了同步锁，以此来保证线程安全。但HashTable的线程安全是以牺牲性能为代价的，因为每次操作都需要加锁，这会极大的影响程序的性能，不利于高并发场景的需求。因此它也被其它更优秀的集合类替代了，比如ConcurrentHashMap。
>
>   ConcurrentHashMap是一个支持高并发更新与查询的哈希表，是线程安全的。他继承了AbstractMap类，与HashMap是同级别的， 主要分为两个版本，一个是jdk7的版本，以分段锁来实现同步；一个是jdk8的版本，通过node节点+CAS算法+锁实现同步。
>
>   *   jdk7版本：可以理解为ConcurrentHashMap维护了一个长度为16的数组，这个数组的长度不会被改变，在数组中可以存储真正的HashMap结构。它是一种分段锁的思想：将维护的数组分为16段，每段分别上锁，这样可以减少锁的竞争，提高并发性，在最优的情况下可以让16个线程同时操作这个Map集合。
>   *   jdk8版本：思想是通过原子操作和局部加锁的方法保证了多线程的线程安全，从而尽可能减少了性能损耗
>       *   node是ConcurrentHashMap中的一个静态内部类，与HashMap里的node实现基本类似，也是最核心的内部类，所有插入ConcurrentHashMap的数据都包装在这里面。ConcurrentHashMap将node数组作为容器，Java官网称这个容器为bin，因为它是懒加载的，在首次使用时才初始化，并根据需要调整大小，容器的大小总是二的幂次方。ConcurrentHashMap会将每个bin中的第一个node上锁，每个bin的第一个node插入就需要用到CAS算法，其余的node插入、删除、替换操作就需要对bin中的第一个node加锁后再进行操作。
>       *   CAS的全称是Compare And Swap，即比较和交换，它的思想是乐观锁的思想，在操作数据时不对数据进行加锁，在提交的时候再验证是否存在冲突。它是一种原子操作，其中包含三个操作数，一个是需要更新的变量的内存位置，一般用V标识；一个是期望值，一般用E标识；一个是新值，一般用N标识。整个CAS算法的思路是线程根据V的内存位置获取具体的值，然后与期望值进行比较，如果比较结果相等，则将这个值修改为新值；如果比较结果不相等，那么就会认为有其它线程已经做了更新，此时他可以有两种策略，一种是重新获取V指向的值再次与期望值比较，重复执行比较交换操作，另一种就是直接结束线程。这个需要根据具体业务来做决策。
>           *   悲观锁：以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作
>           *   乐观锁：操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才来验证数据是否存在冲突，可以通过加版本号然后进行版本号的对比
>           *   原子操作是指一个独立而不可分割的操作，这个操作要么全部完成，要么全部不完成，不可能只完成一部分。在现代操作系统中，原子操作通常用于实现一些同步操作，从而实现数据的一致性和并发控制
>       *   此外，还有TreeNode、TreeBin等其它内部类，都是用于包装。
>       *   此外，ArrayList和HashSet也不是并发安全的，它们也有对应的用于并发场景的实现类，分别是CopyOnWriteArrayList、CopyOnWriteArraySet。
>   *   程序在运行时能够同时更新ConcurrentHashMap且不产生锁竞争的最大线程数默认是16，这个值可以在构造函数中设置。如果自己设置了并发度，ConcurrentHashMap会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32